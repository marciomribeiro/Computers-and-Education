% terminar comentarios de Rohit
% - abort?
% - replicacao da estratégia. Quantas provas? Responsabilidades prof-aluno.
% - figura longe
% - melhorar as figuras dos graficos
% - site do paper

\section{Introduction}

Introductory programming courses are often perceived by the students as problematic~\cite{yadin-inroads-acm-11}. This understanding seems to be based on the high dropout rates~\cite{camel-2006, what-works-cacm-2013}, which has been observed in universities around the world, such as at the United States~\cite{bennedsen-sigcse-failure-rates-2007}, Finland~\cite{why-dropout-icer06}, and ours in Brazil.

To predict the students likely to succeed or fail, previous studies provide aptitude tests regarding programming activities. These studies focus on identifying qualitatively the student skills and consider many different variables from big, complicated, and time-consuming surveys. Also, they might bring subjectiveness due to the interview process. To perform the predictions, they use past academic achievement~\cite{hostetler-aptitude-1983, butcher-predictor-high-school-1985}, diagnostic and math/logic-based tasks~\cite{simon-predictors-ace2006, ibm-aptitude-test}, mental models~\cite{camel-2006}, games~\cite{lorenzenC06-mastermind-predictor-sigcse2008}, and even programming languages~\cite{harris-assembly-jcsc2014}. Thus, although we can predict the potential failing students by using these studies, setting, executing, and replicating them is hard, time consuming and require extra effort from the professors.

In this context, there is a lack of an automatic approach capable of predicting a set of students that will fail. This way, professors and mentors would be able to act and consequently help them. To achieve promising results, however, this approach must accomplish two main requirements. First, it must correctly predict as soon as possible, otherwise there will be not enough time to act and the student would drop out the course anyway. Also, due to the strong prerequisites of understanding previous classes to understand the current one in programming courses (e.g., to understand loops, students must understand conditional structures), the situation gets worse, even when acting just a bit late. Second, the approach must be automatic, requiring almost no effort from professors and mentors and allowing them to use it in every course they teach.

%When considering programming courses, the situation gets worse, even when acting just a bit late, due to the strong prerequisites of understanding previous classes to understand the current one (e.g., to understand loops, students must understand conditional structures). Second, the approach must require almost no effort from professors and mentors, otherwise they might not use it.


%Previous research introduce predictors to identify these students. However, they use aptitude tests and surveys to qualitatively identify the student skills and decide whether the student will succeed or fail~\cite{butcher-predictor-high-school-1985, simon-predictors-ace2006, camel-2006}. They also consider lots of variables, which makes the studies hard to replicate and to execute, being time consuming and increasing the professor effort.


%To reduce effort, the prediction must be automatic, requiring .

%However, identifying potential failing students during introductory programming courses is a non-trivial task~\cite{}, specially if we consider that this identification must be done as soon as possible, otherwise there will be no enough time to act and the student will drop out the course anyway. When considering programming courses, the situation gets worse even when acting just a bit late, due to the strong prerequisites of understanding previous classes to understand the current one (e.g., to understand loops, students must understand conditional structures).

%we often apply aptitude tests \textit{before} the enrolments. 

%~\cite{yadin-inroads-acm-11}. In particular, this problem has been seen in universities around the world, such as at the United States~\cite{bennedsen-sigcse-failure-rates-2007}, Finland~\cite{why-dropout-icer06}, and ours in Brazil. Due to such high failing rates, these courses are often perceived by the students as problematic~\cite{yadin-inroads-acm-11}. In this context, by analyzing the several reasons of why students fail~\cite{why-dropout-icer06}, such as lack of motivation, lack of time, and the chosen programming language, previous work report approaches to reduce these rates~\cite{yadin-inroads-acm-11, xxx}.

%These studies focus on data, reasons, and characteristics \textit{after} the student fail. Nevertheless, there is a lack of an approach capable of identifying that students are not comfortable still during the course. This way, professors and mentors would be able to act and consequently help them. However, identifying potential failing students during introductory programming courses is a non-trivial task~\cite{}, specially if we consider that this identification must be done as soon as possible, otherwise there will be no enough time to act and the student will drop out the course anyway. When considering programming courses, the situation gets worse even when acting just a bit late, due to the strong prerequisites of understanding previous classes to understand the current one (e.g., to understand loops, students must understand conditional structures).

To minimize this problem, in this article we propose an automatic strategy to early predict failing students in introductory programming courses. Our strategy consists of three simple steps. The first one is to make students use an online judge system. This kind of system executes an online submitted solution to a given problem against a set of predefined test cases to check whether the solution is correct or not. Then, we collect metrics of each student by using such a system. Finally, we execute a clustering algorithm~\cite{hartigan-clustering-algorithms-1975} to form groups so that we are able to separate the potential failing students from the other ones.

To evaluate our strategy, we conduct an empirical study regarding 7 introductory programming courses---3.5 years; 7 semesters---with, in total, \totalStudents freshmen students (32 per course, on average). The courses focused on the C language and have been given by the same professor at the Federal University of Alagoas in Brazil. We apply our strategy considering the first 30 days of the programming course (\semesterPercentage of each semester). The results suggest that our strategy can early predict the majority of the failing students within only 30 days. In particular, from the group of students our strategy points as ``likely to fail,'' 72\% of the students indeed fail with 95\% standard confidence level. Moreover, we observe that the 28\% our strategy misses is still important to take into account, since at least 33\% of these students have difficulties to pass and reach the final exam. So, although they pass, this set has good candidates that need special attention as well. Also, we conclude that the efficacy of our strategy can strongly depend on the number of students in the course. Because the strategy is automatic, the effort to predict the potential failing students in a course with hundreds~\cite{bennedsen-sigcse-failure-rates-2007} can significantly reduce. In case the course has few students (e.g., 10 students), we report that our strategy adds little, since the own professor can identify the failing candidates.

%In case professors and mentors help these students, they may avoid final exams and achieve better grades at the end of the course.

In summary, this article provides the following contributions:

\begin{itemize}

	\item A strategy to early predict automatically the potential failing students in introductory programming courses;
	
	\item An empirical study assessing the potential of our strategy. We evaluate our strategy by using \totalStudents students from 7 courses during 3.5 years, demonstrating significant potential.

\end{itemize}

We organize the remainder of this article as follows. Section~\ref{sec:problem} discusses in detail the problem we address in this work. Then, Section~\ref{sec:strategy} introduces our strategy and details the three steps we consider. Section~\ref{sec:evaluation} presents the evaluation we perform whereas Section~\ref{sec:results} discusses the results and findings. We then discuss the related work in Section~\ref{sec:related}. Last but not least, we present the concluding remarks in Section~\ref{sec:conclusion}.